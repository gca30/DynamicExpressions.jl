        - 
        - module ShapeInferenceModule
        - 
        - using ...NodeModule: TensorNode
        - using ..OperatorEnumModule: TensorOperatorEnum
        - using ..FlattenedTensorListModule: FlattenedTensorList
        - using ...TensorNodeUtilsModule: recalculate_node_indices!, number_of_indices
        - # using ..TensorExpressionModule: AbstractTensorExpression, get_tree, get_operators
        - 
        - # ----------------------
        - # DEFINITIONS
        - # ----------------------
        - 
        - mutable struct Constraint
      128     tuple :: Vector{Int32} # the a-variable numbers
        -     sets :: Array{Int32, 3} 
        -     # the axes represent:
        -         # 1. the union axis (how many options are there)
        -         # 2. the a-variable axis (wth length equal to length(tuple))
        -         # 3. the m-variable axis (with the first element in that axis being constant and others variables)
        - end
        - 
        - # the outside is stored as:
        - mutable struct CombinedConstraints
        -     values :: Matrix{Int32}
        -     # the union axis size is implied to be 1, and the tuple is taken to be the range from 1 to the number of avars
     1024     CombinedConstraints(A, M) = new(zeros(Int32, A, M))
        - end
        - 
        - 
        - 
        - # ----------------------
        - # HELPER FUNCTIONS
        - # ----------------------
        - 
        - @inline Base.zero(::Type{Constraint}) = Constraint(Vector{Int32}(undef, 0), Array{Int32, 3}(undef, 0, 0, 0))
        - @inline sets_size(c::Constraint) = size(c.sets, 1)
        - @inline avars_size(c::Constraint) = size(c.sets, 2)
        - @inline mvars_size(c::Constraint) = size(c.sets, 3)
        - 
        - @inline sets_size(cb::CombinedConstraints) = 1
        - @inline avars_size(cb::CombinedConstraints) = size(cb.values, 1)
        - @inline mvars_size(cb::CombinedConstraints) = size(cb.values, 2)
        - 
        - @inline expand_mvars(mat::Matrix) = cat(mat, zeros(eltype(mat), size(mat)...); dims=2)
        - @inline expand_mvars!(cb::CombinedConstraints) = begin
        -     cb.values = expand_mvars(cb.values)
        - end
        - 
        - @inline mvar_occupied(cb::CombinedConstraints, mx) = any(!=(0), @view(cb.values[:,mx]))
        - @inline mvar_occupied(cbv::AbstractMatrix, mx) = any(!=(0), @view(cbv[:,mx]))
        - @inline mvar_occupied(c::Constraint, mx) = any(sx -> mvar_occupied(@view(c.sets[sx, :, :]), mx), axes(c.sets, 1))
        - @inline avar_occupied(cb::CombinedConstraints, ax) = any(!=(0), @view(cb.values[ax,:]))
        - @inline avar_constant(cb::CombinedConstraints, ax) = all(==(0), @view(cb.values[ax,2:end]))
        - @inline avar_nzconstant(cb::CombinedConstraints, ax) = cb.values[ax,1] != 0 && avar_constant(cb, ax)
        - @inline avar_constant(ar::AbstractArray) = all(==(0), @view(ar[2:end]))
        - @inline avar_constant(c::Constraint, sx, ax) = all(==(0), @view(c.sets[sx,ax,2:end]))
        - @inline avar_count(cb::CombinedConstraints) = count(ax -> avar_occupied(cb, ax), axes(cb.values, 1))
        - @inline mvar_count(cb::CombinedConstraints) = count(mx -> mvar_occupied(cb, mx), 2:size(cb.values, 2))+1
        0 @inline mvar_count(cbv::AbstractMatrix) = count(mx -> mvar_occupied(cbv, mx), 2:size(cbv, 2))+1
        - @inline Base.isempty(c::Constraint) = length(c.sets) == 0
        - 
        - first_unused_var!(cb::CombinedConstraints) = begin
        -     for mx in axes(cb.values, 2)
        -         if mx == 1 continue end
        -         if !mvar_occupied(cb, mx) return mx end
        -     end
        -     mx = size(cb.values, 2) + 1
        -     expand_mvars!(cb)
        -     return mx
        - end
        - first_unused_var!(cb::CombinedConstraints, constsMap::CombinedConstraints) = begin
        0     for mx in axes(cb.values, 2)
        0         if mx == 1 continue end
        0         if !mvar_occupied(cb, mx) && !mvar_occupied(constsMap, mx) return mx end
        0     end
        0     mx = size(cb.values, 2) + 1
        0     expand_mvars!(cb)
        0     expand_mvars!(constsMap)
        0     return mx
        - end
        - 
        - function replace_var!(cb::CombinedConstraints, mx, val::AbstractVector{Int32})
        0     @assert size(cb.values, 2) == length(val)
        0     for ax in axes(cb.values, 1)
        0         if cb.values[ax, mx] == 0 
        -             continue
        -         end
        0         coef = cb.values[ax, mx]
        0         cb.values[ax, mx] = 0
        0         @. @view(cb.values[ax,:]) += val * coef
        0     end
        - end
        - 
        - function renormalize_mvars!(cbv::AbstractMatrix{Int32})
        -     nmx = 1
        -     omx = 1
        0     while omx < size(cbv, 2)
        0         omx+=1
        0         if mvar_occupied(cbv, omx)
        0             nmx += 1
        0             if nmx == omx continue end
        0             @. @view(cbv[:,nmx]) = @view(cbv[:, omx])
        -         end
        0     end 
        0     @. @view(cbv[:,(nmx+1):end]) = 0
        0     return nmx
        - end
        - 
        - function renormalize_mvars!(cb::CombinedConstraints)
        -     nmx = 1
        -     omx = 1
        0     while omx < size(cb.values, 2)
        0         omx+=1
        0         if mvar_occupied(cb.values, omx)
        0             nmx += 1
        0             if nmx == omx continue end
        0             @. @view(cb.values[:,nmx]) = @view(cb.values[:, omx])
        -         end
        0     end 
        0     cb.values = copy(@view(cb.values[:, 1:nmx]))
        0     return nmx
        - end
        - 
        - function renormalize_mvars!(c::Constraint)
        -     tmx = 0
        0     for sx in axes(c.sets, 1)
        0         nmx = renormalize_mvars!(@view(c.sets[sx,:,:]))
        0         tmx = max(tmx, nmx)
        0     end
        0     c.sets = copy(@view(c.sets[:,:,1:tmx]))
        0     return tmx
        - end
        - 
        - 
        - # ----------------------
        - # ALGORITHM IMPLEMENTATION
        - # ----------------------
        - 
        - function solve_dioph(c::Constraint, cb::CombinedConstraints, constsMap::CombinedConstraints, axc::Integer)
        0     error("solve_dioph not yet implemented")
        -     # EARLIER IMPLEMENTATION:
        -     # cnt = count(!=(0), @view(result[2:end]))
        -     # temp = Vector{MVector{4, Int32}}(undef, cnt)
        -     # #             bc, u, v, index
        -     # first = true
        -     # for i in reverse(eachindex(result))
        -     #     if result[i] == 0 || i == 1 continue end
        -     #     if first
        -     #         first = false
        -     #         temp[cnt][1] = result[i]
        -     #         temp[cnt][2] = 1
        -     #         temp[cnt][3] = 0
        -     #         temp[cnt][4] = i
        -     #         cnt -= 1
        -     #     else
        -     #         g, u, v = gcdx(result[i], temp[cnt+1][1])
        -     #         temp[cnt][1] = g
        -     #         temp[cnt][2] = u
        -     #         temp[cnt][3] = v
        -     #         temp[cnt][4] = i
        -     #         cnt -= 1
        -     #     end
        -     # end
        -     # if mod(result[1], temp[1][4]) != 0
        -     #     return 2, ax # no solutions error
        -     # end
        - 
        -     # K = first_unused_var!(cb, constsMap)
        -     # if K > currentVars
        -     #     currentVars = varvecsize(cb)
        -     #     constsMap = expand(constsMap)
        -     # end
        -     # nc = zeros(Int32, currentVars)
        -     # ncc = zeros(Int32, currentVars)
        -     # nc[1] = -div(result[1], temp[1][4])
        -     # for i in eachindex(temp)
        -     #     if i == length(temp)
        -     #         continue 
        -     #     end 
        -     #     @. ncc = nc * temp[i][2]
        -     #     ncc[K] += div(temp[i+1][1], temp[i][1])
        -     #     replace_var!(cb.values, temp[i][4], ncc)
        -     #     replace_var!(constsMap, temp[i][4], ncc)
        -     #     @. nc = nc * temp[i][3]
        -     #     nc[K] -= div(temp[i][1], temp[i][1])
        -     #     K = temp[i][4]
        -     #     if i == length(temp)-1
        -     #         replace_var!(cb.values, temp[i+1][4], nc)
        -     #         replace_var!(constsMap, temp[i+1][4], nc)
        -     #     end
        -     # end
        -     return 1000, 1
        - end
        - 
        - function outsubst(c::Constraint, cb::CombinedConstraints)
        0     Ac = avars_size(c)
        0     Mc = mvars_size(c)
        0     Mcb = mvars_size(cb)
     3680     constsMap = CombinedConstraints(Mc, Mcb)
        -     # the avars of constsMap are mvars in c
        -     #   with the first one being a temporary array
        -     # the mvars of constsMap are mvars in cb
        - 
        0     for axc in 1:Ac
        0         avc = c.tuple[axc]
        -         axcb = avc
        0         if !avar_occupied(cb, axcb)
        -             # we haven't encountered this a-var in the combined constants so far
        0             cb.values[avc, 1] = c.sets[1, axc, 1]
        0             for mxc in 2:Mc
        0                 if c.sets[1, axc, mxc] == 0 continue end
        0                 if !avar_occupied(constsMap, mxc)
        -                     # if we don't know the value of a m-var in c, we say it is a new m-var in cb
        0                     mxcb = first_unused_var!(cb, constsMap)
        0                     constsMap.values[mxc, mxcb] = 1
        -                 end
        -                 # println(@view(constsMap.values[mxc, :]) .* c.sets[1, axc, mxc])
        0                 @. @view(cb.values[axcb, :]) += @view(constsMap.values[mxc, :]) * c.sets[1, axc, mxc]
        0             end
        -             continue
        -         end
        -         # we have encountered this a-var in the combined constants already
        - 
        -         # we require all m-vars in c to have a corresponding value in cb
        0         for mxc in 2:Mc
        0             if c.sets[1, axc, mxc] == 0 continue end
        0             if !avar_occupied(constsMap, mxc)
        -                 # if we don't know the value of a m-var in c, we say it is a new m-var in cb
        0                 mxcb = first_unused_var!(cb, constsMap)
        0                 constsMap.values[mxc, mxcb] = 1
        -             end
        0         end
        - 
        0         @. @view(constsMap.values[1, :]) = -@view(cb.values[axcb, :])
        -         # the constraint is (the a-var in c) = (the a-var in cb)
        0         constsMap.values[1, 1] += c.sets[1, axc, 1]
        0         for mxc in 2:Mc
        0             if c.sets[1, axc, mxc] == 0 continue end
        0             @. @view(constsMap.values[1, :]) += @view(constsMap.values[mxc, :])
        0         end
        - 
        -         # now the constraint is (the a-var in cb) = 0
        -         # it is a linear diophantine equation
        -         # print("The constraint on cb is: ")
        -         # print_mvars(stdout, constsMap.values[1,:])
        -         # print(" = 0\n")
        - 
        0         if avar_constant(constsMap, 1)
        0             if constsMap.values[1, 1] == 0
        -                 continue
        -             else
        0                 return 1, axcb
        -             end
        -         end
        - 
        0         if !any(x -> abs(x) == 1, @view(constsMap.values[1, 2:end]))
        0             code, axerr = solve_dioph(c, cb, constsMap, axc)
        -             if code != 0
        -                 return code, axerr
        -             end
        -             continue
        -         end
        - 
        -         # if there are any variables with coefficients equal to 1, it is pretty easy to solve
        -         # there is an extraneous variable wich is equal to the linear combination of the other variables
        0         mxcb = findfirst(x -> abs(x) == 1, @view(constsMap.values[1, 2:end])) + 1
        0         coef = constsMap.values[1, mxcb]
        0         constsMap.values[1, mxcb] = 0
        0         if coef == 1
        0             @. @view(constsMap.values[1, :]) = - @view(constsMap.values[1, :])
        -         end
        -         # print("the result is: ")
        -         # print_mvars(stdout, begin x = zeros(Int32, mvars_size(cb)); x[mxcb] = 1; x end)
        -         # print(" = ")
        -         # print_mvars(stdout, @view(constsMap.values[1, :]))
        -         # print("\n")
        -         # println(cb)
        0         replace_var!(cb, mxcb, @view(constsMap.values[1, :]))
        0         replace_var!(constsMap, mxcb, @view(constsMap.values[1, :]))
        -         # println(cb)
        0     end
        - 
        0     return 0, 0
        - end
        - 
        - function should_innersubst(c::Constraint, cb::CombinedConstraints)
        0     Ac = avars_size(c)
        0     for axc in 1:Ac
        0         if avar_nzconstant(cb, c.tuple[axc])
        0             return true 
        -         end
        0     end
        0     return false
        - end
        - 
        - function innersubst(c::Constraint, cb::CombinedConstraints)
        0     Ac = avars_size(c)
        0     Mc = mvars_size(c)
        0     S = sets_size(c)
        -     # this is an outsubst problem
      576     virtual_cb = CombinedConstraints(Ac, Mc)
        0     virtual_tuple = filter((axc) -> avar_nzconstant(cb, c.tuple[axc]), eachindex(c.tuple))
      768     virtual_c = Constraint(
        -         virtual_tuple,
        -         reshape(map(axc -> cb.values[c.tuple[axc], 1], virtual_tuple), (1, length(virtual_tuple), 1))
        -     )
        -     # println(virtual_c)
        -     errax = 0
        -     errcode = 0
        - 
      768     new_sets_u = Array{Int32, 3}(undef, S, Ac, Mc)
        -     newS = 0
        -     newM = 1
        0     newA = Ac - length(virtual_tuple)
        0     for sx in 1:S
        0         @. virtual_cb.values = @view(c.sets[sx, :, :])
        -         # println("WE HAVE: ", virtual_cb)
        -         # println("WITH ", virtual_c)
        0         errcode, errax = outsubst(virtual_c, virtual_cb)
        0         if errcode != 0
        -             continue
        -         end
        0         newS += 1
        0         @. @view(new_sets_u[newS, :, :]) = virtual_cb.values
        0         Ms = renormalize_mvars!(@view(c.sets[newS, :, :]))
        0         newM = max(newM, Ms)
        0     end
        0     if newS == 0
        -         # we have a special case here, when there is a constraint that completely contradicts what we have
        0         return 100, c.tuple[errax] 
        -     end
        - 
        -     # we now shrink the constraint
      416     new_sets = Array{Int32, 3}(undef, newS, newA, newM)
      384     new_tuple = Vector{Int32}(undef, newA)
        -     axxv = 1
        0     for axc in eachindex(c.tuple)
        0         if axxv <= length(virtual_tuple) && axc == virtual_tuple[axxv]
        0             axxv += 1
        -         else
        0             new_tuple[axc-axxv+1] = axc
        -         end
        0     end
        0     for sx in 1:newS, ax in 1:newA
        0         @. @view(new_sets[sx, ax, :]) = @view(new_sets_u[sx, new_tuple[ax], 1:newM])
        0     end
        0     map!(axx -> c.tuple[axx], new_tuple, new_tuple)
        0     c.tuple = new_tuple
        0     c.sets = new_sets
        -     # println("NEW VALUE: ", c)
        0     return 0, 0
        - end
        - 
        - # 0 if they are not subsets of each other
        - # 1 if s1 is a subset of s2
        - # 2 if s2 is a subset of s1
        - # 3 if they are equivalent
        - function subset_comparison(c::Constraint, s1::Integer, s2::Integer)
        -     # s1 is a subset of s2 if we can find variables such that the equation is compatible
        -     # this can be done using outsubst (we say we have a set that is the combined constraints and a set that is )
        0     Mb = mvars_size(c)
        0     Ab = avars_size(c)
      800     virtual_cb = CombinedConstraints(Ab, Mb)
        0     virtual_cb.values .= @view(c.sets[s1, :, :])
      960     virtual_c = Constraint(collect(1:Ab), c.sets[s2:s2,:,:])
        0     initial_mvars_1 = mvar_count(@view(c.sets[s1,:,:]))
        0     initial_mvars_2 = mvar_count(@view(c.sets[s2,:,:]))
        0     ercode, _ = outsubst(virtual_c, virtual_cb)
        0     if ercode != 0 # not compatible
        0         return 0
        0     elseif initial_mvars_1 == initial_mvars_2 
        -         # the dimensionality is the same, and if they are compatible, it means they are equivalent
        0         return 3
        0     elseif initial_mvars_1 < initial_mvars_2
        0         return 1
        -     else
        0         return 2
        -     end
        -     
        - end
        - 
        - function simplify(cs::AbstractVector{Constraint}, ci::Integer)
        -     # simplifies constraints that have redundant sets
        0     Sb = sets_size(cs[ci])
        0     if Sb < 2 return 0, 0 end
        0     Mb = mvars_size(cs[ci])
        0     Ab = avars_size(cs[ci])
        -     
        -     # for every set, we check if there is a set that is a subset of the original
        -     # if it is, we remove it
      448     save_map = zeros(Int32, Sb)
        0     save_map[1] = 1
        -     save_count = 1
        0     for sx in 2:Sb
        -         save_flag = true
        0         for j in 1:(sx-1)
        0             sc = subset_comparison(cs[ci], sx, j)
        0             if sc == 0 # incompatible
        -                 # save the set if there are only incompatibilities
        -                 continue
        0             elseif sc == 1 || sc == 3 # sx subset of j or equivalent set
        -                 # don't save the set
        -                 # do nothing with it
        -                 save_flag = false
        -                 break  
        0             elseif sc == 2 # j subset of sc
        -                 # replace the set with sc
        -                 # don't save as a new set
        0                 save_map[sx] = save_map[j]
        0                 save_map[j] = 0
        -                 save_flag = false
        -                 break
        -             end
        -             # if they are equal we must onyl remove 1
        -             #if j > sx && @view(cs[ci].sets[sx, :, :]) == @view(cs[ci].sets[j, :, :]) continue end 
        0         end
        - 
        0         if save_flag
        0             save_map[sx] = save_count+1
        0             save_count += 1
        -         end
        0     end
        - 
      416     new_sets = Array{Int32, 3}(undef, save_count, Ab, Mb)
        0     for savex in eachindex(save_map)
        0         if save_map[savex] == 0 continue end
        0         @view(new_sets[save_count,:,:]) .=  @view(cs[ci].sets[save_map[savex],:,:])
        0         save_count -= 1
        0     end
        0     cs[ci].sets = new_sets
        0     renormalize_mvars!(cs[ci])
        0     for sx in axes(cs[ci].sets, 1), ax in axes(cs[ci].sets, 2)
        0         if avar_constant(cs[ci], sx, ax) && cs[ci].sets[sx,ax,1] < 0
        0             return 33, ci
        -         end
        0     end
        - 
        0     return 0, 0
        - end
        - 
        - function split_by_variables(cs::AbstractVector{Constraint}, ci::Integer)
        0     Sb = sets_size(cs[ci])
        0     if Sb < 2 return 0, 0 end
        0     Mb = mvars_size(cs[ci])
        0     Ab = avars_size(cs[ci])
      384     avars_map = zeros(Int32, Ab)
      384     mvars_map = zeros(Int32, Mb-1) # what constraint does the mvar fall in (0 for not yet determined)
        -     ccount = 0
        -     count_minus1 = 0
        0     for sx in 1:Sb, ax in 1:Ab
        0         if avars_map[ax] != -1 && cs[ci].sets[sx, ax, 1] != cs[ci].sets[1, ax, 1]
        0             avars_map[ax] = -1 # means that we should include it in every set, except the constants one
        0             count_minus1 += 1
        -         end
        0     end
        - 
        0     for sx in 1:Sb
        0         mvars_map .= 0
        0         for ax in 1:Ab, mx in 2:Mb
        0             if cs[ci].sets[sx, ax, mx] == 0
        -                 continue
        -             end
        0             mm = mvars_map[mx-1]
        0             am = avars_map[ax]
        0             if mm == 0 && am != 0
        0                 mvars_map[mx-1] = am
        0             elseif mm != 0 && am == 0
        0                 avars_map[ax] = mm
        0             elseif mm == 0 && am == 0
        0                 avars_map[ax] = ccount + 1
        0                 mvars_map[mx-1] = ccount + 1
        0                 ccount += 1
        0             elseif mm != am && am != -1
        0                 toreplace = max(mm, am)
        0                 replacedwith = min(mm, am)
        0                 replace!(x -> x == toreplace ? replacedwith : (x > toreplace ? x-1 : x), mvars_map)
        0                 replace!(x -> x == toreplace ? replacedwith : (x > toreplace ? x-1 : x), avars_map)
        0                 ccount -= 1
        0             elseif mm != am && am == -1
        0                 replace!(x -> x == mm ? -1 : (x > mm ? x-1 : x), mvars_map)
        0                 ccount -= 1 
        -             end
        0         end
        0     end
        - 
        -     # when avars_map contains -1, means that we have constants that differ depending on the case
        -     # when avars_map contains 0, it means that it is a constant that is the same across the field
        -     # when avars_map contains >0, it means that we can split in evenly
        0     count_0 = count(==(0), avars_map)
        0     if count_0 != 0
        0         new_tuple = filter(x -> avars_map[x] == 0, eachindex(avars_map))
        0         new_sets = Array{Int32, 3}(undef, 1, length(new_tuple), 1)
        0         for nax in eachindex(new_tuple)
        0             new_sets[1, nax, 1] = cs[ci].sets[1, new_tuple[nax], 1]
        0         end
        0         replace!(x -> cs[ci].tuple[x], new_tuple)
        0         push!(cs, Constraint(
        -             new_tuple, new_sets
        -         ))
        -     end
        0     for i in 1:ccount
        0         new_tuple = filter(x -> avars_map[x] == i || avars_map[x] == -1, eachindex(avars_map))
        0         new_sets = Array{Int32, 3}(undef, Sb, length(new_tuple), Mb)
        0         for nax in eachindex(new_tuple)
        0             @view(new_sets[:, nax, :]) .= @view(cs[ci].sets[:, new_tuple[nax], :])
        0         end
        0         replace!(x -> cs[ci].tuple[x], new_tuple)
        0         push!(cs, Constraint(
        -             new_tuple, new_sets
        -         ))
        0         erc, erv = simplify(cs, length(cs))
        0         if erc != 0
        0             return erc, erv
        -         end
        0     end
        0     if ccount == 0
        0         new_tuple = filter(x -> avars_map[x] == -1, eachindex(avars_map))
      416         new_sets = Array{Int32, 3}(undef, Sb, length(new_tuple), Mb)
        0         for nax in eachindex(new_tuple)
        0             @view(new_sets[:, nax, :]) .= @view(cs[ci].sets[:, new_tuple[nax], :])
        0         end
        0         replace!(x -> cs[ci].tuple[x], new_tuple)
      192         push!(cs, Constraint(
        -             new_tuple, new_sets
        -         ))
        0         erc, erv = simplify(cs, length(cs))
        0         if erc != 0
        0             return erc, erv
        -         end
        -     end
      960     cs[ci] = zero(Constraint)
        - 
        0     return 0,0
        - end
        - 
        - function split_and_simplify(cs::AbstractVector{Constraint}, ci::Integer)
        -     return split_by_variables(cs, ci)
        - end
        - 
        - function shape_inference_iteration(cs::Vector{Constraint}, cb::CombinedConstraints)
        -     
        -     things_did = 1
        0     while things_did != 0
        -         things_did = 0
        -         
        -         # outer substitution
        0         for ci in eachindex(cs)
        0             if sets_size(cs[ci]) == 1
        0                 things_did += 1
        -                 # print("---------------------------\nDoing outside substitution for ")
        -                 # println(cs[ci])
        0                 code, ax = outsubst(cs[ci], cb)
        0                 if code != 0
        0                     error("Error code $(code), conflicting a-variable $(ax)")
        -                 end
     1920                 cs[ci] = zero(Constraint)
        -                 # println(cb)
        -                 # println(cs)
        -             end
        0         end
        - 
        -         # inner substitution
        0         for ci in eachindex(cs)
        0             if should_innersubst(cs[ci], cb)
        -                 # print("---------------------------\nDoing inside substitution for ")
        -                 # println(cs[ci])
        0                 things_did += 1
        0                 code, ax = innersubst(cs[ci], cb)
        0                 if code != 0
        0                     error("Error code $(code), conflicting a-variable $(ax)")
        -                 end
        0                 code, ax = split_and_simplify(cs, ci)
        0                 if code != 0
        0                     error("Error code $(code), conflicting a-variable $(ax)")
        -                 end
        -                 # println(cb)
        -                 # println(cs)
        -             end
        0         end
        - 
        0         if things_did > 0
        0             filter!(c -> !isempty(c), cs)
        -         end
        - 
        -     end
        0     renormalize_mvars!(cb)
        - 
        - end
        - 
        - 
        - # ----------------------
        - # PRINTING
        - # ----------------------
        - 
        - @inline print_delimited(io, print_element, delim, v::AbstractVector) = begin
        -     printed = false
        -     for i in eachindex(v)
        -         if printed print(io, delim) end
        -         print_element(io, v[i])
        -         printed = true
        -     end
        - end
        - @inline print_parensd(io, print_element, delim, v::AbstractVector) = begin
        -     if length(v) > 1 print(io, "(") end
        -     print_delimited(io, print_element, delim, v)
        -     if length(v) > 1 print(io, ")") end
        - end
        - 
        - print_mvars(io, r::AbstractVector{Int32}) = begin
        -     printed = false
        -     for i in eachindex(r)
        -         if r[i] == 0 continue end
        -         letter = (printed ? (r[i] < 0 ?  " - " : " + ") : (r[i] < 0 ? "-" : "")) * 
        -             (abs(r[i]) != 1 || i == 1 ? "$(abs(r[i]))" : "") *
        -             (i != 1 ? "nmlkopqrstuvwxyzbcdefghij"[mod(i-2,25)+1] : "") *
        -             (i > 24 ? "$(div(i-2,25)+1)" : "")
        -         print(io, letter)
        -         printed = true
        -     end
        - end
        - 
        - Base.show(io::IO, c::Constraint) = begin
        -     if length(c.tuple) == 0
        -         print(io, "EMPTY")
        -         return
        -     end
        -     A = avars_size(c)
        -     S = sets_size(c)
        -     print_parensd(io, (io, av) ->  print(io, "a$(av)"), ", ", c.tuple)
        -     print(io, " ∈ ")
        -     print_delimited(io, (io, set) -> begin
        -         print_parensd(io, print_mvars, ", ", [set[ax,:] for ax in 1:A])
        -     end, " ∪ ", [c.sets[sx,:,:] for sx in 1:S])
        - end
        - 
        - Base.show(io::IO, cb::CombinedConstraints) = begin
        -     print(io, "COMBINED: $(avar_count(cb)) entries\n")
        -     for ax in axes(cb.values, 1)
        -         if !avar_occupied(cb, ax) continue end
        -         print(io, "  a$(ax) = ")
        -         print_mvars(io, cb.values[ax,:])
        -         print(io, "\n")
        -     end
        -     #print(io, "\n")
        - end
        - 
        - Base.show(io::IO, cs::Vector{Constraint}) = begin
        -     print(io, "OUTER: $(length(cs)) entries\n")
        -     print_delimited(io, (io, c) -> begin  
        -         print(io, "  ")
        -         print(io, c)
        -     end, "\n", cs)
        -     # print("\n\n")
        - end
        - 
        - # --------------------
        - # FINAL FORM
        - # -------------------
        - 
        - macro make_constraint(tuple, sets...)
       96     if tuple.head != :tuple || length(sets) == 0
        0         !all(set -> set.head == :tuple, sets) || 
        -         !all(set -> length(set.args) == length(tuple.args), sets)
        0         error("The constraint has incorrect form. The correct form is: \n" *
        -             "(tuple of integers representing the indices in the array of shapes (a-vars)) = sets...\n" *
        -             "with each set being a tuple of same size containg linear expressions using constants and arbitrarily named variables (m-vars)")
        -     end
        -     
      112     mvars_dicts = map(set -> begin
        -         # get number of variables
      112         d = Dict{Symbol, Int32}()
      224         function traverse(expr)
        -             if expr isa Symbol
        0                 if !(expr in keys(d)) && !(expr in (:+, :-, :*))
        0                     d[expr] = length(d)+2
        -                 end
        -             elseif expr isa Expr
        0                 for arg in expr.args
        0                     traverse(arg)
        0                 end
        -             end
        -         end
        0         traverse(set)
        0         return d
        -     end, sets)
        0     S = length(sets)
        0     A = length(tuple.args)
        0     M = maximum(d -> length(d)+1, mvars_dicts)
      192     finalsets = zeros(Int32, (S, A, M))
        - 
        0     function show_err()
        0         error("The expressions inside the set must be a linear combination of constants and variables" * 
        -         ", so the only allowed operations are +, - and *. You also can't multiply variables together.")
        -     end
        - 
      208     function lc_eval(sx, expr) # it returns an vector of size M being the linear combination of those
        -         if expr isa Symbol
     1888             toret = zeros(Int32, M)
        0             toret[mvars_dicts[sx][expr]] = 1
        0             return toret
        -         elseif expr isa Integer
      224             toret = zeros(Int32, M)
        0             toret[1] = expr
        0             return toret
        -         elseif expr isa Expr
        0             if expr.head != :call
        0                 show_err()
        -             end
        0             if expr.args[1] == :+
      160                 toret = zeros(Int32, M)
        0                 for i in 2:length(expr.args)
      128                     toret .+= lc_eval(sx, expr.args[i])
        0                 end
        0                 return toret
        0             elseif expr.args[1] == :-
        0                 if length(expr.args) == 3
       64                     return lc_eval(sx, expr.args[2]) .- lc_eval(sx, expr.args[3])
        0                 elseif length(expr.args) == 2
        0                     return .- lc_eval(sx, expr.args[2])
        -                 else
        0                     show_err()
        -                 end
        0             elseif expr.args[1] == :*
        0                 vv = map(ex -> lc_eval(sx, ex), expr.args[2:end])
        0                 count_vv = count(ve -> !avar_constant(ve), vv)
        0                 if count_vv == 0
        0                     toret = zeros(Int32, M)
        0                     toret[1] = prod(ve -> ve[1], vv)
        0                     return toret
        0                 elseif count_vv == 1
        0                     varx = findfirst(ve -> !avar_constant(ve), vv)
        0                     for i in eachindex(vv)
        0                         if i == varx continue end
        0                         vv[varx] .*= vv[i][1]
        0                     end
        0                     return vv[varx]
        -                 else
        0                     show_err()
        -                 end
        -             else
        0                 show_err()
        -             end
        -         else
        -             show_err()
        -         end
        -     end
        - 
      832     for sx in 1:S, ax in 1:A
     4224         @view(finalsets[sx, ax, :]) .= lc_eval(sx, sets[sx].args[ax])
      576     end
     3120     return quote
      672         $(esc(:Constraint))(
        -             $(esc(Expr(:ref, :(Int32), tuple.args...))),
        -             $finalsets
        -         )
        -     end
        - end
        - 
        - function push_constraints_broadcast(cs::AbstractVector{Constraint}, (outoffset, loffset)::NTuple{2,<:Integer}, ::Val{N}) where {N}
        0     for nx in 1:N
        -         push!(cs, @make_constraint((outoffset+nx, loffset+nx), (n, n)))
        0     end
        - end
        - 
        - function push_constraints_broadcast(cs::AbstractVector{Constraint}, (outoffset, loffset, roffset)::NTuple{3,<:Integer}, ::Val{N}) where {N}
        0     for nx in 1:N
        -         push!(cs, @make_constraint((outoffset+nx, loffset+nx, roffset+nx), (n, 1, n), (n, n, 1), (n, n, n)))
        0     end
        - end
        - 
        - function default_constraint_indeterminancy_resolve(c::Constraint, node::TensorNode{T,N}, dim::Integer, operators::TensorOperatorEnum) where {T,N}
        -     S = sets_size(c)
        -     s = rand(UInt32)%S+1
        -     return Constraint(c.tuple, c.sets[s:s,:,:])
        - end
        - 
        - function shape_inference(
        -     tree::TensorNode{T,N},
        -     operators::TensorOperatorEnum,
        -     cX_shapes::AbstractVector{NTuple{N, <:Integer}},
        -     desired_shape::NTuple{N, <:Integer};
        -     kws...
        - ) where {N,T}
        -     push!(cX_shapes, desired_shape)
        -     shape_inference(tree, operators, cX_shapes; kws...)
        -     pop!(cX_shapes)
        - end
        - 
        0 function shape_inference(
        -     tree::TensorNode{T,N},
        -     operators::TensorOperatorEnum,
        -     cX::Union{FlattenedTensorList{T,N}, AbstractVector{NTuple{N, <:Integer}}};
        -     indeterminancy_resolve::F1 = default_constraint_indeterminancy_resolve,
        - ) where {N,T,F1}
        - 
        -     # now we have indices
       96     recalculate_node_indices!(tree)
        0     A = number_of_indices(tree)*N
      768     cb = CombinedConstraints(A, 5)
       96     cs = Constraint[]
      256     sizehint!(cs, A)
        - 
      320     function traverse(node)
        0         if node.degree == 0
        0             if !node.constant
      320                 push!(cs, Constraint(
        -                     collect((node.index-1)*N .+ (1:N)),
        -                     reshape(collect(if cX isa FlattenedTensorList 
        0                         cX.positions[node.feature].shape
        -                     else
      704                         cX[node.feature]
        -                     end), (1, N, 1))  
        -                 ))
        -                 # println("appending for ", node, " : ", cs[length(cs)])
        -             end
        0         elseif node.degree == 1
        0             traverse(node.l)
        -             # i = length(cs)+1
        0             operators.unaops[node.op].push_constraints!(cs, ((node.index-1)*N, (node.l.index-1)*N), Val(N))
        -             # print("appending for ", node, " : ")
        -             # for ix in i:length(cs)
        -             #     print(cs[ix], "   ")
        -             # end
        -             # print("\n")
        0         elseif node.degree == 2
        0             traverse(node.l)
        0             traverse(node.r)
        -             # i = length(cs)+1
      480             operators.binops[node.op].push_constraints!(cs, ((node.index-1)*N, (node.l.index-1)*N, (node.r.index-1)*N), Val(N))
        -             # print("appending for ", node, " : ")
        -             # for ix in i:length(cs)
        -             #     print(cs[ix], "   ")
        -             # end
        -             # print("\n")
        -         end
        -     end
       32     function get_node_by_index(node, index)
        0         if node.degree == 0
        0             if node.index == index
        0                 return node
        -             end
        0         elseif node.degree == 1
        0             if index == node.index
        0                 return node
        0             elseif index <= node.l.index
        0                 return get_node_by_index(node.l, index)
        -             end
        0         elseif node.degree == 2
        0             if index <= node.l.index
        0                 return get_node_by_index(node.l, index)
        0             elseif index <= node.r.index
        0                 return get_node_by_index(node.r, index)
        0             elseif index == node.index
        0                 return node
        -             end
        -         end
        -     end
      160     push!(cs, Constraint(
        -         collect((tree.index-1)*N .+ (1:N)),
        -         reshape(collect(
        -             if cX isa FlattenedTensorList 
        0                 cX.positions[length(cX.positions)-1].shape
        -             else
      352                 cX[length(cX)]
        -             end
        -         ), (1, N, 1))
        -     ))
        0     traverse(tree)
        - 
        -     # println("--------- INITIAL SITUATION ------------")
        -     # println(cb)
        -     # println(cs)
        - 
        0     while true
        0         shape_inference_iteration(cs, cb)
        -         # println("------- PARTIALLY FINAL SITUATION ------------")
        -         # println(cb)
        -         # println(cs)
        0         if length(cs) != 0
        -             # node = get_node_by_index()
        0             node = get_node_by_index(tree, div(cs[1].tuple[1], N))
        0             S = sets_size(cs[1])
        0             s = rand(UInt32)%S+1
       64             cs[1] = Constraint(cs[1].tuple, cs[1].sets[s:s,:,:])
        -             #cs[1] = indeterminancy_resolve(cs[1], node, mod(cs[1].tuple[1], N), operators)
        0         elseif mvars_size(cb) != 1
        0             z = zeros(Int32, mvars_size(cb))
        0             z[1] = rand(UInt32)%5+1
        -                 # TODO: create some sort of generator, given the already used shape, the operator, the nodes, etc
        -                 # maybe each operator should have a default generator that is random?
        -                 # this also means that
        0             replace_var!(cb, 2, z)
        -         else
        -             break
        -         end
        -     end
        - 
        -     # println("------- FULLY FINAL SITUATION ------------")
        -     # println(cb)
        -     # println(cs)
        - 
       64     function final_traverse(node)
        0         if node.degree == 1
        0             final_traverse(node.l)
        0         elseif node.degree == 2
      128             final_traverse(node.l)
      128             final_traverse(node.r)
        -         end
        0         node.shape = ntuple(i -> cb.values[(node.index-1)*N+i], Val(N))
        -     end
       64     final_traverse(tree)
        - 
        - end
        - 
        - # @inline shape_inference(te::AbstractTensorExpression, args...; kwargs) = shape_inference(get_tree(te), get_operators(te), args...; kwargs...)
        - 
        - 
        - end
